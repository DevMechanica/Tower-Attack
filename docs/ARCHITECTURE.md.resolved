# Game Engine Architecture

This document explains the technical design of the game engine. We have moved away from a monolithic "God Class" to a modular **MVC (Model-View-Controller)** architecture designed for multiplayer.

## 1. High-Level Data Flow

The game follows a strict **unidirectional data flow**, similar to Redux or Flux:

```mermaid
graph LR
    User[User Input] --> Input[InputManager]
    Input --> Command[Command Object]
    Command --> Network[NetworkManager]
    Network --> Game[Game Controller]
    Game --> State[GameState]
    State --> Renderer[Renderer]
    GameLoop[GameLoop] --> Game
```

1.  **Input:** User clicks/keys are captured.
2.  **Command:** Inputs are converted into serializable **Commands** (e.g., `{ type: 'SPAWN_UNIT', x: 10, y: 20 }`).
3.  **Network:** Commands are broadcast to all players (currently via `BroadcastChannel` for local tabs).
4.  **Game:** The [Game](file:///d:/WORK/PurviProekt/src/Game.js#15-324) class receives commands and updates the [GameState](file:///d:/WORK/PurviProekt/src/GameState.js#2-44).
5.  **State:** The [GameState](file:///d:/WORK/PurviProekt/src/GameState.js#2-44) holds all data (units, health, gold). It contains **NO** logic.
6.  **Render:** The [Renderer](file:///d:/WORK/PurviProekt/src/Renderer.js#2-104) reads [GameState](file:///d:/WORK/PurviProekt/src/GameState.js#2-44) 60 times a second and draws it.

---

## 2. Core Components

### [src/GameState.js](file:///d:/WORK/PurviProekt/src/GameState.js) (The Model)
*   **Purpose:** The "Single Source of Truth".
*   **Contents:** Lists of units, towers, projectiles, players' gold/lives.
*   **Key Feature:** It is **Serializable**. Calling [serialize()](file:///d:/WORK/PurviProekt/src/GameState.js#20-31) gives you a pure JSON object representing the entire world. This is essential for:
    *   Saving/Loading games.
    *   Sending the game state to a new player joining a match.
    *   Debug replays.

### [src/GameLoop.js](file:///d:/WORK/PurviProekt/src/GameLoop.js) (The Clock)
*   **Purpose:** separation of **Simulation Time** vs **Real Time**.
*   **Mechanism:** Runs the game logic at a fixed **20 Ticks/Second**.
*   **Why?** In multiplayer, if one player has a 144Hz monitor and another has 60Hz, a frame-based loop would make the 144Hz player move faster. [GameLoop](file:///d:/WORK/PurviProekt/src/GameLoop.js#2-56) ensures both run at exactly the same speed.

### [src/Renderer.js](file:///d:/WORK/PurviProekt/src/Renderer.js) (The View)
*   **Purpose:** Visuals only.
*   **Behavior:** It takes the [GameState](file:///d:/WORK/PurviProekt/src/GameState.js#2-44) and paints it. It does not calculate collisions or move units.
*   **Independence:** You could swap this for a 3D renderer (Three.js) without changing a single line of game logic.

### [src/NetworkManager.js](file:///d:/WORK/PurviProekt/src/NetworkManager.js) (The Connector)
*   **Purpose:** Abstraction of the network layer.
*   **Current Mode:** uses `BroadcastChannel` to talk between browser tabs.
*   **Future Mode:** Can be swapped to use `socket.io` or `WebSockets` to talk to a Node.js server. The rest of the game won't know the difference.

### [src/Game.js](file:///d:/WORK/PurviProekt/src/Game.js) (The Controller)
*   **Purpose:** The conductor.
*   **Responsibility:**
    *   Initializes all other systems.
    *   Receives Commands from [NetworkManager](file:///d:/WORK/PurviProekt/src/NetworkManager.js#2-39).
    *   Executes logic (e.g., "If SPAWN command received -> Deduct Gold -> Add Unit to State").
    *   Triggers the Loop.

---

## 3. How to Add Features

**Example: Adding a new "Freeze Spell"**

1.  **Command:** Add `FREEZE_SPELL` to `CommandType` in [InputManager.js](file:///d:/WORK/PurviProekt/src/InputManager.js).
2.  **Input:** In [InputManager](file:///d:/WORK/PurviProekt/src/InputManager.js#8-97), listen for the key press (e.g., 'F') and emit a `{ type: 'FREEZE_SPELL' }` command.
3.  **Logic:** In [Game.js](file:///d:/WORK/PurviProekt/src/Game.js) inside [executeCommand()](file:///d:/WORK/PurviProekt/src/Game.js#125-176), handle `FREEZE_SPELL`:
    *   Iterate `this.state.units` and set their `frozen` flag to true.
4.  **View:** In [Renderer.js](file:///d:/WORK/PurviProekt/src/Renderer.js), check `unit.frozen`. If true, draw a blue tint over the unit.

You never mix these steps. The Renderer never listens for the 'F' key directly!
