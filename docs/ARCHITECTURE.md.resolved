# Tower Attack: Architecture Deep Dive

This document outlines the technical design of the Tower Attack game. It explains how the pieces fit together, from the server-side matchmaking to the client-side game loop.

## 1. High-Level Architecture
The game follows a **Client-Server** architecture (for Online Mode) and a **Peer-to-Peer** simulation (for Local Mode).

*   **Frontend**: Vanilla JavaScript (ES Modules). No heavy frameworks (React/Vue) were used for the game loop to ensure maximum performance and control.
*   **Backend**: Node.js with socket.io for robust real-time communication.
*   **Infrastructure**: Google App Engine (Standard Environment).

---

## 2. Core Components (Client)

### A. The Engine ([Game.js](file:///d:/WORK/PurviProekt/src/Game.js))
This is the central hub. It initializes all other systems and ties them together.
*   **Responsibilities**:
    *   Holds the "Truth" (Units, Towers, Gold, Lives).
    *   Manages the main Game Loop (`requestAnimationFrame`).
    *   Routes inputs to logic and logic to the renderer.

### B. Network Layer ([NetworkManager.js](file:///d:/WORK/PurviProekt/src/NetworkManager.js))
This is the "Brain" of the multiplayer system. It abstracts away *how* we are sending messages so the rest of the game doesn't care if we are online or offline.
*   **Automatic Mode Switching**: Detects if you are on `localhost` or the `cloud` URL.
*   **Transports**:
    *   **SocketTransport**: Uses `socket.io` for Online play. Robust against firewalls and proxies.
    *   **LocalTransport**: Uses `BroadcastChannel` for tab-to-tab communication (Zero latency, no server needed).

### C. Input Handling ([InputManager.js](file:///d:/WORK/PurviProekt/src/InputManager.js))
Listens for user clicks and taps.
*   **Command Pattern**: It does *not* modify the game state directly. Instead, it generates **Commands** (e.g., `PLACE_TOWER`, `SPAWN_UNIT`).
*   **Deterministic Execution**: These commands are sent to the network. The game only updates when it *receives* the command back (or processes it locally), ensuring both players see the exact same thing.

### D. Rendering (`Renderer.js` + `Effects.js`)
Purely visual. Reads the state and draws it to the HTML5 Canvas.
*   **Separation of Concerns**: The Renderer doesn't know rules (e.g., "towers cost gold"). It just knows "Draw a tower at X,Y".

---

## 3. Server Architecture ([server.js](file:///d:/WORK/PurviProekt/server.js))

The server is lightweight and stateless regarding game rules. It is a **Relay Server**.

*   **Technology**: Node.js + Express + Socket.IO.
*   **Matchmaking**:
    *   Players join a `waitingPlayers` queue.
    *   When 2 players are in queue, they are paired (`socket.partner = otherSocket`).
    *   The server assigns roles: Player 1 = Defender, Player 2 = Attacker.
*   **Message Relaying**:
    *   The sever blindly forwards messages. If Attacker sends "Spawn Unit", server passes it to Defender.
    *   The server does *not* simulate the game. This reduces server load to near zero.

---

## 4. Data Flow (The "Lifecycle of a Click")

1.  **Input**: User clicks "Spawn Unit".
2.  **Validation**: [InputManager](file:///d:/WORK/PurviProekt/src/InputManager.js#9-101) checks context (Are you the Attacker? Do you have gold?).
3.  **Command**: A `SPAWN_UNIT` command object is created.
4.  **Network**:
    *   **Online**: Sent via WebSocket to Server -> Server relays -> Received by Opponent.
    *   **Local**: Sent via BroadcastChannel -> Received by other Tab.
5.  **Execution**: [Game.js](file:///d:/WORK/PurviProekt/src/Game.js) executes [executeCommand()](file:///d:/WORK/PurviProekt/src/Game.js#186-253).
6.  **Update**: Unit is added to `this.units`.
7.  **Render**: `Renderer.js` draws the new unit on the next frame.

---

## 5. Key Design Decisions

*   **Socket.IO over Native WebSockets**:
    *   *Why?* Google Cloud Load Balancers aggressively strip non-standard headers. Native WebSockets often failed connection handshakes. Socket.IO starts with HTTP Long-Polling (which always works) and upgrades seamlessly, ensuring 100% connectivity.
*   **BroadcastChannel for Local**:
    *   *Why?* Allows disconnected development. You can code on a train with no internet and still test multiplayer logic between two tabs.
